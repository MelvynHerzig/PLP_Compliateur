-----------------------------------------------------------------------------
Info file generated by Happy Version 1.20.0 from parser.y
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parser -> Prg                               (0)
	Prg -> Expr                                        (1)
	Prg -> FDef Prg                                    (2)
	FDef -> define funName Args '=' Expr               (3)
	Args -> varName                                    (4)
	Args -> varName Args                               (5)
	Expr -> let varName '=' Expr in Expr               (6)
	Expr -> if Expr then Expr else Expr                (7)
	Expr -> Expr '+' Expr                              (8)
	Expr -> Expr '-' Expr                              (9)
	Expr -> Expr '*' Expr                              (10)
	Expr -> Expr '<' Expr                              (11)
	Expr -> '(' '-' Expr ')'                           (12)
	Expr -> '(' '+' Expr ')'                           (13)
	Expr -> integer                                    (14)
	Expr -> varName                                    (15)
	Expr -> funName '(' Exprs ')'                      (16)
	Expr -> '(' Expr ')'                               (17)
	Exprs -> Expr                                      (18)
	Exprs -> Expr Exprs                                (19)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	let            { TLet }
	in             { TIn }
	if             { TIf }
	then           { TThen }
	else           { TElse }
	define         { TDefine }
	integer        { TInt $$ }
	varName        { TVarName $$ }
	funName        { TFunName $$ }
	'='            { TSym '=' }
	'+'            { TSym '+' }
	'-'            { TSym '-' }
	'*'            { TSym '*' }
	'<'            { TSym '<' }
	'('            { TOp }
	')'            { TCp }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parser   rule  0
	Prg             rules 1, 2
	FDef            rule  3
	Args            rules 4, 5
	Expr            rules 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17
	Exprs           rules 18, 19

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0

	%start_parser -> . Prg                              (rule 0)

	let            shift, and enter state 3
	if             shift, and enter state 4
	define         shift, and enter state 11
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Prg            goto state 9
	FDef           goto state 10
	Expr           goto state 2

State 1

	Prg -> . Expr                                       (rule 1)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 2

State 2

	Prg -> Expr .                                       (rule 1)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	%eof           reduce using rule 1


State 3

	Expr -> let . varName '=' Expr in Expr              (rule 6)

	varName        shift, and enter state 19


State 4

	Expr -> if . Expr then Expr else Expr               (rule 7)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 18

State 5

	Expr -> integer .                                   (rule 14)

	let            reduce using rule 14
	in             reduce using rule 14
	if             reduce using rule 14
	then           reduce using rule 14
	else           reduce using rule 14
	define         reduce using rule 14
	integer        reduce using rule 14
	varName        reduce using rule 14
	funName        reduce using rule 14
	'+'            reduce using rule 14
	'-'            reduce using rule 14
	'*'            reduce using rule 14
	'<'            reduce using rule 14
	'('            reduce using rule 14
	')'            reduce using rule 14
	%eof           reduce using rule 14


State 6

	Expr -> varName .                                   (rule 15)

	let            reduce using rule 15
	in             reduce using rule 15
	if             reduce using rule 15
	then           reduce using rule 15
	else           reduce using rule 15
	define         reduce using rule 15
	integer        reduce using rule 15
	varName        reduce using rule 15
	funName        reduce using rule 15
	'+'            reduce using rule 15
	'-'            reduce using rule 15
	'*'            reduce using rule 15
	'<'            reduce using rule 15
	'('            reduce using rule 15
	')'            reduce using rule 15
	%eof           reduce using rule 15


State 7

	Expr -> funName . '(' Exprs ')'                     (rule 16)

	'('            shift, and enter state 17


State 8

	Expr -> '(' . '-' Expr ')'                          (rule 12)
	Expr -> '(' . '+' Expr ')'                          (rule 13)
	Expr -> '(' . Expr ')'                              (rule 17)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'+'            shift, and enter state 15
	'-'            shift, and enter state 16
	'('            shift, and enter state 8

	Expr           goto state 14

State 9

	%start_parser -> Prg .                              (rule 0)

	%eof           accept


State 10

	Prg -> FDef . Prg                                   (rule 2)

	let            shift, and enter state 3
	if             shift, and enter state 4
	define         shift, and enter state 11
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Prg            goto state 13
	FDef           goto state 10
	Expr           goto state 2

State 11

	FDef -> define . funName Args '=' Expr              (rule 3)

	funName        shift, and enter state 12


State 12

	FDef -> define funName . Args '=' Expr              (rule 3)

	varName        shift, and enter state 36

	Args           goto state 35

State 13

	Prg -> FDef Prg .                                   (rule 2)

	%eof           reduce using rule 2


State 14

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)
	Expr -> '(' Expr . ')'                              (rule 17)

	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	')'            shift, and enter state 34


State 15

	Expr -> '(' '+' . Expr ')'                          (rule 13)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 33

State 16

	Expr -> '(' '-' . Expr ')'                          (rule 12)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 32

State 17

	Expr -> funName '(' . Exprs ')'                     (rule 16)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 30
	Exprs          goto state 31

State 18

	Expr -> if Expr . then Expr else Expr               (rule 7)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	then           shift, and enter state 29
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23


State 19

	Expr -> let varName . '=' Expr in Expr              (rule 6)

	'='            shift, and enter state 28


State 20

	Expr -> Expr '+' . Expr                             (rule 8)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 27

State 21

	Expr -> Expr '-' . Expr                             (rule 9)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 26

State 22

	Expr -> Expr '*' . Expr                             (rule 10)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 25

State 23

	Expr -> Expr '<' . Expr                             (rule 11)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 24

State 24

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)
	Expr -> Expr '<' Expr .                             (rule 11)

	let            reduce using rule 11
	in             reduce using rule 11
	if             reduce using rule 11
	then           reduce using rule 11
	else           reduce using rule 11
	define         reduce using rule 11
	integer        reduce using rule 11
	varName        reduce using rule 11
	funName        reduce using rule 11
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            reduce using rule 11
	'('            reduce using rule 11
	')'            reduce using rule 11
	%eof           reduce using rule 11


State 25

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr '*' Expr .                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	let            reduce using rule 10
	in             reduce using rule 10
	if             reduce using rule 10
	then           reduce using rule 10
	else           reduce using rule 10
	define         reduce using rule 10
	integer        reduce using rule 10
	varName        reduce using rule 10
	funName        reduce using rule 10
	'+'            reduce using rule 10
	'-'            reduce using rule 10
	'*'            reduce using rule 10
	'<'            reduce using rule 10
	'('            reduce using rule 10
	')'            reduce using rule 10
	%eof           reduce using rule 10


State 26

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr '-' Expr .                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	let            reduce using rule 9
	in             reduce using rule 9
	if             reduce using rule 9
	then           reduce using rule 9
	else           reduce using rule 9
	define         reduce using rule 9
	integer        reduce using rule 9
	varName        reduce using rule 9
	funName        reduce using rule 9
	'+'            reduce using rule 9
	'-'            reduce using rule 9
	'*'            shift, and enter state 22
	'<'            reduce using rule 9
	'('            reduce using rule 9
	')'            reduce using rule 9
	%eof           reduce using rule 9


State 27

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr '+' Expr .                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	let            reduce using rule 8
	in             reduce using rule 8
	if             reduce using rule 8
	then           reduce using rule 8
	else           reduce using rule 8
	define         reduce using rule 8
	integer        reduce using rule 8
	varName        reduce using rule 8
	funName        reduce using rule 8
	'+'            reduce using rule 8
	'-'            reduce using rule 8
	'*'            shift, and enter state 22
	'<'            reduce using rule 8
	'('            reduce using rule 8
	')'            reduce using rule 8
	%eof           reduce using rule 8


State 28

	Expr -> let varName '=' . Expr in Expr              (rule 6)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 44

State 29

	Expr -> if Expr then . Expr else Expr               (rule 7)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 43

State 30

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)
	Exprs -> Expr .                                     (rule 18)
	Exprs -> Expr . Exprs                               (rule 19)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	'('            shift, and enter state 8
	')'            reduce using rule 18

	Expr           goto state 30
	Exprs          goto state 42

State 31

	Expr -> funName '(' Exprs . ')'                     (rule 16)

	')'            shift, and enter state 41


State 32

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)
	Expr -> '(' '-' Expr . ')'                          (rule 12)

	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	')'            shift, and enter state 40


State 33

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)
	Expr -> '(' '+' Expr . ')'                          (rule 13)

	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	')'            shift, and enter state 39


State 34

	Expr -> '(' Expr ')' .                              (rule 17)

	let            reduce using rule 17
	in             reduce using rule 17
	if             reduce using rule 17
	then           reduce using rule 17
	else           reduce using rule 17
	define         reduce using rule 17
	integer        reduce using rule 17
	varName        reduce using rule 17
	funName        reduce using rule 17
	'+'            reduce using rule 17
	'-'            reduce using rule 17
	'*'            reduce using rule 17
	'<'            reduce using rule 17
	'('            reduce using rule 17
	')'            reduce using rule 17
	%eof           reduce using rule 17


State 35

	FDef -> define funName Args . '=' Expr              (rule 3)

	'='            shift, and enter state 38


State 36

	Args -> varName .                                   (rule 4)
	Args -> varName . Args                              (rule 5)

	varName        shift, and enter state 36
	'='            reduce using rule 4

	Args           goto state 37

State 37

	Args -> varName Args .                              (rule 5)

	'='            reduce using rule 5


State 38

	FDef -> define funName Args '=' . Expr              (rule 3)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 47

State 39

	Expr -> '(' '+' Expr ')' .                          (rule 13)

	let            reduce using rule 13
	in             reduce using rule 13
	if             reduce using rule 13
	then           reduce using rule 13
	else           reduce using rule 13
	define         reduce using rule 13
	integer        reduce using rule 13
	varName        reduce using rule 13
	funName        reduce using rule 13
	'+'            reduce using rule 13
	'-'            reduce using rule 13
	'*'            reduce using rule 13
	'<'            reduce using rule 13
	'('            reduce using rule 13
	')'            reduce using rule 13
	%eof           reduce using rule 13


State 40

	Expr -> '(' '-' Expr ')' .                          (rule 12)

	let            reduce using rule 12
	in             reduce using rule 12
	if             reduce using rule 12
	then           reduce using rule 12
	else           reduce using rule 12
	define         reduce using rule 12
	integer        reduce using rule 12
	varName        reduce using rule 12
	funName        reduce using rule 12
	'+'            reduce using rule 12
	'-'            reduce using rule 12
	'*'            reduce using rule 12
	'<'            reduce using rule 12
	'('            reduce using rule 12
	')'            reduce using rule 12
	%eof           reduce using rule 12


State 41

	Expr -> funName '(' Exprs ')' .                     (rule 16)

	let            reduce using rule 16
	in             reduce using rule 16
	if             reduce using rule 16
	then           reduce using rule 16
	else           reduce using rule 16
	define         reduce using rule 16
	integer        reduce using rule 16
	varName        reduce using rule 16
	funName        reduce using rule 16
	'+'            reduce using rule 16
	'-'            reduce using rule 16
	'*'            reduce using rule 16
	'<'            reduce using rule 16
	'('            reduce using rule 16
	')'            reduce using rule 16
	%eof           reduce using rule 16


State 42

	Exprs -> Expr Exprs .                               (rule 19)

	')'            reduce using rule 19


State 43

	Expr -> if Expr then Expr . else Expr               (rule 7)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	else           shift, and enter state 46
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23


State 44

	Expr -> let varName '=' Expr . in Expr              (rule 6)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	in             shift, and enter state 45
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23


State 45

	Expr -> let varName '=' Expr in . Expr              (rule 6)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 49

State 46

	Expr -> if Expr then Expr else . Expr               (rule 7)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'('            shift, and enter state 8

	Expr           goto state 48

State 47

	FDef -> define funName Args '=' Expr .              (rule 3)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	let            reduce using rule 3
	if             reduce using rule 3
	define         reduce using rule 3
	integer        reduce using rule 3
	varName        reduce using rule 3
	funName        reduce using rule 3
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	'('            reduce using rule 3


State 48

	Expr -> if Expr then Expr else Expr .               (rule 7)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	let            reduce using rule 7
	in             reduce using rule 7
	if             reduce using rule 7
	then           reduce using rule 7
	else           reduce using rule 7
	define         reduce using rule 7
	integer        reduce using rule 7
	varName        reduce using rule 7
	funName        reduce using rule 7
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	'('            reduce using rule 7
	')'            reduce using rule 7
	%eof           reduce using rule 7


State 49

	Expr -> let varName '=' Expr in Expr .              (rule 6)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '<' Expr                             (rule 11)

	let            reduce using rule 6
	in             reduce using rule 6
	if             reduce using rule 6
	then           reduce using rule 6
	else           reduce using rule 6
	define         reduce using rule 6
	integer        reduce using rule 6
	varName        reduce using rule 6
	funName        reduce using rule 6
	'+'            shift, and enter state 20
	'-'            shift, and enter state 21
	'*'            shift, and enter state 22
	'<'            shift, and enter state 23
	'('            reduce using rule 6
	')'            reduce using rule 6
	%eof           reduce using rule 6


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 20
Number of terminals: 16
Number of non-terminals: 6
Number of states: 50
