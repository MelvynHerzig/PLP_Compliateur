-----------------------------------------------------------------------------
Info file generated by Happy Version 1.20.0 from parser.y
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parser -> Prg                               (0)
	Prg -> Expr                                        (1)
	Prg -> FDef                                        (2)
	FDef -> define funName Args '=' Expr               (3)
	Args ->                                            (4)
	Args -> varName Args                               (5)
	Expr -> let varName '=' Expr in Expr               (6)
	Expr -> if Expr then Expr else Expr                (7)
	Expr -> Expr '+' Expr                              (8)
	Expr -> Expr '-' Expr                              (9)
	Expr -> Expr '*' Expr                              (10)
	Expr -> Expr '/' Expr                              (11)
	Expr -> Expr '<' Expr                              (12)
	Expr -> '(' '-' Expr ')'                           (13)
	Expr -> '(' '+' Expr ')'                           (14)
	Expr -> '#' Expr                                   (15)
	Expr -> integer                                    (16)
	Expr -> varName                                    (17)
	Expr -> funName '(' Exprs ')'                      (18)
	Expr -> '(' Expr ')'                               (19)
	Exprs ->                                           (20)
	Exprs -> Expr Exprs                                (21)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	let            { TLet }
	in             { TIn }
	if             { TIf }
	then           { TThen }
	else           { TElse }
	define         { TDefine }
	integer        { TInt $$ }
	varName        { TVarName $$ }
	funName        { TFunName $$ }
	'='            { TSym '=' }
	'+'            { TSym '+' }
	'-'            { TSym '-' }
	'*'            { TSym '*' }
	'/'            { TSym '/' }
	'<'            { TSym '<' }
	'#'            { TSym '#' }
	'('            { TOp }
	')'            { TCp }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parser   rule  0
	Prg             rules 1, 2
	FDef            rule  3
	Args            rules 4, 5
	Expr            rules 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
	Exprs           rules 20, 21

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0

	%start_parser -> . Prg                              (rule 0)

	let            shift, and enter state 3
	if             shift, and enter state 4
	define         shift, and enter state 12
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Prg            goto state 10
	FDef           goto state 11
	Expr           goto state 2

State 1

	Prg -> . Expr                                       (rule 1)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 2

State 2

	Prg -> Expr .                                       (rule 1)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	%eof           reduce using rule 1


State 3

	Expr -> let . varName '=' Expr in Expr              (rule 6)

	varName        shift, and enter state 20


State 4

	Expr -> if . Expr then Expr else Expr               (rule 7)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 19

State 5

	Expr -> integer .                                   (rule 16)

	let            reduce using rule 16
	in             reduce using rule 16
	if             reduce using rule 16
	then           reduce using rule 16
	else           reduce using rule 16
	integer        reduce using rule 16
	varName        reduce using rule 16
	funName        reduce using rule 16
	'+'            reduce using rule 16
	'-'            reduce using rule 16
	'*'            reduce using rule 16
	'/'            reduce using rule 16
	'<'            reduce using rule 16
	'#'            reduce using rule 16
	'('            reduce using rule 16
	')'            reduce using rule 16
	%eof           reduce using rule 16


State 6

	Expr -> varName .                                   (rule 17)

	let            reduce using rule 17
	in             reduce using rule 17
	if             reduce using rule 17
	then           reduce using rule 17
	else           reduce using rule 17
	integer        reduce using rule 17
	varName        reduce using rule 17
	funName        reduce using rule 17
	'+'            reduce using rule 17
	'-'            reduce using rule 17
	'*'            reduce using rule 17
	'/'            reduce using rule 17
	'<'            reduce using rule 17
	'#'            reduce using rule 17
	'('            reduce using rule 17
	')'            reduce using rule 17
	%eof           reduce using rule 17


State 7

	Expr -> funName . '(' Exprs ')'                     (rule 18)

	'('            shift, and enter state 18


State 8

	Expr -> '#' . Expr                                  (rule 15)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 17

State 9

	Expr -> '(' . '-' Expr ')'                          (rule 13)
	Expr -> '(' . '+' Expr ')'                          (rule 14)
	Expr -> '(' . Expr ')'                              (rule 19)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'+'            shift, and enter state 15
	'-'            shift, and enter state 16
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 14

State 10

	%start_parser -> Prg .                              (rule 0)

	%eof           accept


State 11

	Prg -> FDef .                                       (rule 2)

	%eof           reduce using rule 2


State 12

	FDef -> define . funName Args '=' Expr              (rule 3)

	funName        shift, and enter state 13


State 13

	FDef -> define funName . Args '=' Expr              (rule 3)

	varName        shift, and enter state 39
	'='            reduce using rule 4

	Args           goto state 38

State 14

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)
	Expr -> '(' Expr . ')'                              (rule 19)

	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	')'            shift, and enter state 37


State 15

	Expr -> '(' '+' . Expr ')'                          (rule 14)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 36

State 16

	Expr -> '(' '-' . Expr ')'                          (rule 13)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 35

State 17

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)
	Expr -> '#' Expr .                                  (rule 15)

	let            reduce using rule 15
	in             reduce using rule 15
	if             reduce using rule 15
	then           reduce using rule 15
	else           reduce using rule 15
	integer        reduce using rule 15
	varName        reduce using rule 15
	funName        reduce using rule 15
	'+'            reduce using rule 15
	'-'            reduce using rule 15
	'*'            reduce using rule 15
	'/'            reduce using rule 15
	'<'            reduce using rule 15
	'#'            reduce using rule 15
	'('            reduce using rule 15
	')'            reduce using rule 15
	%eof           reduce using rule 15


State 18

	Expr -> funName '(' . Exprs ')'                     (rule 18)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9
	')'            reduce using rule 20

	Expr           goto state 33
	Exprs          goto state 34

State 19

	Expr -> if Expr . then Expr else Expr               (rule 7)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	then           shift, and enter state 32
	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25


State 20

	Expr -> let varName . '=' Expr in Expr              (rule 6)

	'='            shift, and enter state 31


State 21

	Expr -> Expr '+' . Expr                             (rule 8)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 30

State 22

	Expr -> Expr '-' . Expr                             (rule 9)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 29

State 23

	Expr -> Expr '*' . Expr                             (rule 10)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 28

State 24

	Expr -> Expr '/' . Expr                             (rule 11)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 27

State 25

	Expr -> Expr '<' . Expr                             (rule 12)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 26

State 26

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)
	Expr -> Expr '<' Expr .                             (rule 12)

	let            reduce using rule 12
	in             reduce using rule 12
	if             reduce using rule 12
	then           reduce using rule 12
	else           reduce using rule 12
	integer        reduce using rule 12
	varName        reduce using rule 12
	funName        reduce using rule 12
	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            reduce using rule 12
	'#'            reduce using rule 12
	'('            reduce using rule 12
	')'            reduce using rule 12
	%eof           reduce using rule 12


State 27

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr '/' Expr .                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	let            reduce using rule 11
	in             reduce using rule 11
	if             reduce using rule 11
	then           reduce using rule 11
	else           reduce using rule 11
	integer        reduce using rule 11
	varName        reduce using rule 11
	funName        reduce using rule 11
	'+'            reduce using rule 11
	'-'            reduce using rule 11
	'*'            reduce using rule 11
	'/'            reduce using rule 11
	'<'            reduce using rule 11
	'#'            reduce using rule 11
	'('            reduce using rule 11
	')'            reduce using rule 11
	%eof           reduce using rule 11


State 28

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr '*' Expr .                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	let            reduce using rule 10
	in             reduce using rule 10
	if             reduce using rule 10
	then           reduce using rule 10
	else           reduce using rule 10
	integer        reduce using rule 10
	varName        reduce using rule 10
	funName        reduce using rule 10
	'+'            reduce using rule 10
	'-'            reduce using rule 10
	'*'            reduce using rule 10
	'/'            reduce using rule 10
	'<'            reduce using rule 10
	'#'            reduce using rule 10
	'('            reduce using rule 10
	')'            reduce using rule 10
	%eof           reduce using rule 10


State 29

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr '-' Expr .                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	let            reduce using rule 9
	in             reduce using rule 9
	if             reduce using rule 9
	then           reduce using rule 9
	else           reduce using rule 9
	integer        reduce using rule 9
	varName        reduce using rule 9
	funName        reduce using rule 9
	'+'            reduce using rule 9
	'-'            reduce using rule 9
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            reduce using rule 9
	'#'            reduce using rule 9
	'('            reduce using rule 9
	')'            reduce using rule 9
	%eof           reduce using rule 9


State 30

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr '+' Expr .                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	let            reduce using rule 8
	in             reduce using rule 8
	if             reduce using rule 8
	then           reduce using rule 8
	else           reduce using rule 8
	integer        reduce using rule 8
	varName        reduce using rule 8
	funName        reduce using rule 8
	'+'            reduce using rule 8
	'-'            reduce using rule 8
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            reduce using rule 8
	'#'            reduce using rule 8
	'('            reduce using rule 8
	')'            reduce using rule 8
	%eof           reduce using rule 8


State 31

	Expr -> let varName '=' . Expr in Expr              (rule 6)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 47

State 32

	Expr -> if Expr then . Expr else Expr               (rule 7)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 46

State 33

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)
	Exprs -> Expr . Exprs                               (rule 21)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	'#'            shift, and enter state 8
	'('            shift, and enter state 9
	')'            reduce using rule 20

	Expr           goto state 33
	Exprs          goto state 45

State 34

	Expr -> funName '(' Exprs . ')'                     (rule 18)

	')'            shift, and enter state 44


State 35

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)
	Expr -> '(' '-' Expr . ')'                          (rule 13)

	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	')'            shift, and enter state 43


State 36

	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)
	Expr -> '(' '+' Expr . ')'                          (rule 14)

	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	')'            shift, and enter state 42


State 37

	Expr -> '(' Expr ')' .                              (rule 19)

	let            reduce using rule 19
	in             reduce using rule 19
	if             reduce using rule 19
	then           reduce using rule 19
	else           reduce using rule 19
	integer        reduce using rule 19
	varName        reduce using rule 19
	funName        reduce using rule 19
	'+'            reduce using rule 19
	'-'            reduce using rule 19
	'*'            reduce using rule 19
	'/'            reduce using rule 19
	'<'            reduce using rule 19
	'#'            reduce using rule 19
	'('            reduce using rule 19
	')'            reduce using rule 19
	%eof           reduce using rule 19


State 38

	FDef -> define funName Args . '=' Expr              (rule 3)

	'='            shift, and enter state 41


State 39

	Args -> varName . Args                              (rule 5)

	varName        shift, and enter state 39
	'='            reduce using rule 4

	Args           goto state 40

State 40

	Args -> varName Args .                              (rule 5)

	'='            reduce using rule 5


State 41

	FDef -> define funName Args '=' . Expr              (rule 3)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 50

State 42

	Expr -> '(' '+' Expr ')' .                          (rule 14)

	let            reduce using rule 14
	in             reduce using rule 14
	if             reduce using rule 14
	then           reduce using rule 14
	else           reduce using rule 14
	integer        reduce using rule 14
	varName        reduce using rule 14
	funName        reduce using rule 14
	'+'            reduce using rule 14
	'-'            reduce using rule 14
	'*'            reduce using rule 14
	'/'            reduce using rule 14
	'<'            reduce using rule 14
	'#'            reduce using rule 14
	'('            reduce using rule 14
	')'            reduce using rule 14
	%eof           reduce using rule 14


State 43

	Expr -> '(' '-' Expr ')' .                          (rule 13)

	let            reduce using rule 13
	in             reduce using rule 13
	if             reduce using rule 13
	then           reduce using rule 13
	else           reduce using rule 13
	integer        reduce using rule 13
	varName        reduce using rule 13
	funName        reduce using rule 13
	'+'            reduce using rule 13
	'-'            reduce using rule 13
	'*'            reduce using rule 13
	'/'            reduce using rule 13
	'<'            reduce using rule 13
	'#'            reduce using rule 13
	'('            reduce using rule 13
	')'            reduce using rule 13
	%eof           reduce using rule 13


State 44

	Expr -> funName '(' Exprs ')' .                     (rule 18)

	let            reduce using rule 18
	in             reduce using rule 18
	if             reduce using rule 18
	then           reduce using rule 18
	else           reduce using rule 18
	integer        reduce using rule 18
	varName        reduce using rule 18
	funName        reduce using rule 18
	'+'            reduce using rule 18
	'-'            reduce using rule 18
	'*'            reduce using rule 18
	'/'            reduce using rule 18
	'<'            reduce using rule 18
	'#'            reduce using rule 18
	'('            reduce using rule 18
	')'            reduce using rule 18
	%eof           reduce using rule 18


State 45

	Exprs -> Expr Exprs .                               (rule 21)

	')'            reduce using rule 21


State 46

	Expr -> if Expr then Expr . else Expr               (rule 7)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	else           shift, and enter state 49
	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25


State 47

	Expr -> let varName '=' Expr . in Expr              (rule 6)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	in             shift, and enter state 48
	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25


State 48

	Expr -> let varName '=' Expr in . Expr              (rule 6)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 52

State 49

	Expr -> if Expr then Expr else . Expr               (rule 7)

	let            shift, and enter state 3
	if             shift, and enter state 4
	integer        shift, and enter state 5
	varName        shift, and enter state 6
	funName        shift, and enter state 7
	'#'            shift, and enter state 8
	'('            shift, and enter state 9

	Expr           goto state 51

State 50

	FDef -> define funName Args '=' Expr .              (rule 3)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	%eof           reduce using rule 3


State 51

	Expr -> if Expr then Expr else Expr .               (rule 7)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	let            reduce using rule 7
	in             reduce using rule 7
	if             reduce using rule 7
	then           reduce using rule 7
	else           reduce using rule 7
	integer        reduce using rule 7
	varName        reduce using rule 7
	funName        reduce using rule 7
	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	'#'            reduce using rule 7
	'('            reduce using rule 7
	')'            reduce using rule 7
	%eof           reduce using rule 7


State 52

	Expr -> let varName '=' Expr in Expr .              (rule 6)
	Expr -> Expr . '+' Expr                             (rule 8)
	Expr -> Expr . '-' Expr                             (rule 9)
	Expr -> Expr . '*' Expr                             (rule 10)
	Expr -> Expr . '/' Expr                             (rule 11)
	Expr -> Expr . '<' Expr                             (rule 12)

	let            reduce using rule 6
	in             reduce using rule 6
	if             reduce using rule 6
	then           reduce using rule 6
	else           reduce using rule 6
	integer        reduce using rule 6
	varName        reduce using rule 6
	funName        reduce using rule 6
	'+'            shift, and enter state 21
	'-'            shift, and enter state 22
	'*'            shift, and enter state 23
	'/'            shift, and enter state 24
	'<'            shift, and enter state 25
	'#'            reduce using rule 6
	'('            reduce using rule 6
	')'            reduce using rule 6
	%eof           reduce using rule 6


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 22
Number of terminals: 18
Number of non-terminals: 6
Number of states: 53
